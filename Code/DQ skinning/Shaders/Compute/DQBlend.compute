// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include "DQ.cginc"

struct bone_weight_info
{
	int4 bone_indexes;
	float4 bone_weights;
};

struct vertex_info
{
	float4 position;
	float4 normal;
	float4 tangent;

	int4 bone_indexes;
	float4 bone_weights;
};

bool _OnlyRotation;

RWStructuredBuffer<dual_quaternion> skinned_dual_quaternions;
RWStructuredBuffer<vertex_info> vertex_infos;

uint textureWidth;
RWTexture2D<float4> skinned_data_1;
RWTexture2D<float4> skinned_data_2;
RWTexture2D<float> skinned_data_3;



struct vertex_info SkinVertex(struct vertex_info vertinfo)
{
	int4 bone_indexes	= vertinfo.bone_indexes;
	float4 bone_weights	= vertinfo.bone_weights;

	struct dual_quaternion dq0 = skinned_dual_quaternions.Load(bone_indexes[0]);
	struct dual_quaternion dq1 = skinned_dual_quaternions.Load(bone_indexes[1]);
	struct dual_quaternion dq2 = skinned_dual_quaternions.Load(bone_indexes[2]);
	struct dual_quaternion dq3 = skinned_dual_quaternions.Load(bone_indexes[3]);

	dq1 = DualQuaternionShortestPath(dq1, dq0);
	dq2 = DualQuaternionShortestPath(dq2, dq0);
	dq3 = DualQuaternionShortestPath(dq3, dq0);

	struct dual_quaternion skinned_dq;
	skinned_dq.rotation_quaternion =	dq0.rotation_quaternion * bone_weights[0];
	skinned_dq.rotation_quaternion +=	dq1.rotation_quaternion * bone_weights[1];
	skinned_dq.rotation_quaternion +=	dq2.rotation_quaternion * bone_weights[2];
	skinned_dq.rotation_quaternion +=	dq3.rotation_quaternion * bone_weights[3];

	skinned_dq.translation_quaternion =		dq0.translation_quaternion * bone_weights[0];
	skinned_dq.translation_quaternion +=	dq1.translation_quaternion * bone_weights[1];
	skinned_dq.translation_quaternion +=	dq2.translation_quaternion * bone_weights[2];
	skinned_dq.translation_quaternion +=	dq3.translation_quaternion * bone_weights[3];

	float mag = length(skinned_dq.rotation_quaternion);
	skinned_dq.rotation_quaternion		/= mag;
	skinned_dq.translation_quaternion	/= mag;

	vertinfo.position	= QuaternionApplyRotation(vertinfo.position,	skinned_dq.rotation_quaternion);
	vertinfo.normal		= QuaternionApplyRotation(vertinfo.normal,		skinned_dq.rotation_quaternion);
	vertinfo.tangent	= QuaternionApplyRotation(vertinfo.tangent,		skinned_dq.rotation_quaternion);

	vertinfo.position += QuaternionMultiply(skinned_dq.translation_quaternion * 2, QuaternionInvert(skinned_dq.rotation_quaternion));
	vertinfo.normal = normalize(vertinfo.normal);
	vertinfo.tangent = normalize(vertinfo.tangent);

	return vertinfo;
}

[numthreads(1024,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	int2 pos;
	pos.x = id.x % textureWidth;
	pos.y = id.x / textureWidth;

	struct vertex_info vertinfo = vertex_infos.Load(id.x);

	vertinfo = SkinVertex(vertinfo);

	skinned_data_1[pos] = float4(vertinfo.position.xyz, vertinfo.normal.x);
	skinned_data_2[pos] = float4(vertinfo.normal.yz, vertinfo.tangent.xy);
	skinned_data_3[pos] = vertinfo.tangent.z;
}
